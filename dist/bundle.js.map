{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;AAA6C;AACJ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpN+C;AACV;AACQ;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAS;AACvC;AACA;AACA;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3FyC;AACM;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;;;;;;;;;;;;;;;AClCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRsC;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B;AACA;AACA,kBAAkB,UAAU,GAAG,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmD;AAC5C;AACP;AACA,8BAA8B,2DAAU;AACxC;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,SAAS;AACT;AACA;AACA,eAAe,mBAAO,CAAC,0DAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACjCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D,6BAA6B,gCAAgC;AAC7D,6BAA6B,gCAAgC;AAC7D,+BAA+B,gCAAgC;;;;;;;;;;;;;;;;;UCjB/D;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAC8D;AACX;AACW;AACV;AACpD;AACA,6BAA6B,uEAAgB;AAC7C,yBAAyB,4DAAS;AAClC,4BAA4B,uEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://algo-labyrinte/./src/algorithm/LabyrinthSolver.ts","webpack://algo-labyrinte/./src/mapping/GraphMapper.ts","webpack://algo-labyrinte/./src/mapping/JsonMapper.ts","webpack://algo-labyrinte/./src/model/Labyrinth.ts","webpack://algo-labyrinte/./src/model/Node.ts","webpack://algo-labyrinte/./src/model/NodeGraph.ts","webpack://algo-labyrinte/./src/model/Position.ts","webpack://algo-labyrinte/./src/model/Square.ts","webpack://algo-labyrinte/./src/service/LabyrinthService.ts","webpack://algo-labyrinte/./src/service/StyleService.ts","webpack://algo-labyrinte/./src/utils/Logger.ts","webpack://algo-labyrinte/webpack/bootstrap","webpack://algo-labyrinte/webpack/runtime/define property getters","webpack://algo-labyrinte/webpack/runtime/hasOwnProperty shorthand","webpack://algo-labyrinte/webpack/runtime/make namespace object","webpack://algo-labyrinte/./src/main.ts"],"sourcesContent":["import { Position } from \"../model/Position\";\nimport { Logger } from \"../utils/Logger\";\nclass AdjacentSquares {\n}\n/*\n    The solver needs to return a detailed stack of steps taken to solve the labyrinth\n    The Step class should contain the following information:\n    - The square where the step was taken\n    - What action was taken, visit or backtracking, or both\n\n    */\nexport class LabyrinthSolver {\n    constructor() {\n        this.debug = false;\n    }\n    /**\n     * Finds the adjacent squares to the given square looping around the labyrinth (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    findAdjacentSquaresToLooparound(square, squaresList) {\n        const labXLength = squaresList.map((c) => c.posX).reduce((a, b) => Math.max(a, b)) + 1;\n        const labYLength = squaresList.map((c) => c.posY).reduce((a, b) => Math.max(a, b)) + 1;\n        const offsets = {\n            top: (((square.posY + 1) % labYLength) + labYLength) % labYLength,\n            right: (((square.posX + 1) % labXLength) + labXLength) % labXLength,\n            bottom: (((square.posY - 1) % labYLength) + labYLength) % labYLength,\n            left: (((square.posX - 1) % labXLength) + labXLength) % labXLength,\n        };\n        const positions = {\n            top: new Position(square.posX, offsets.top),\n            bottom: new Position(square.posX, offsets.bottom),\n            right: new Position(offsets.right, square.posY),\n            left: new Position(offsets.left, square.posY),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    /**\n     * Finds all the adjacent squares to the given square (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    getAllNeighbours(square, squaresList) {\n        const positions = {\n            top: new Position(square.posX - 1, square.posY),\n            bottom: new Position(square.posX + 1, square.posY),\n            right: new Position(square.posX, square.posY + 1),\n            left: new Position(square.posX, square.posY - 1),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    getAccessibleNeighbours(square, squaresList) {\n        const neighbours = [];\n        const adjacent = this.getAllNeighbours(square, squaresList);\n        if (adjacent.top) {\n            !(square.walls.top || adjacent.top.walls.bottom) &&\n                !adjacent.top.isVisited()\n                ? neighbours.push(adjacent.top)\n                : null;\n        }\n        if (adjacent.right) {\n            !(square.walls.right || adjacent.right.walls.left) &&\n                !adjacent.right.isVisited()\n                ? neighbours.push(adjacent.right)\n                : null;\n        }\n        if (adjacent.bottom) {\n            !(square.walls.bottom || adjacent.bottom.walls.top) &&\n                !adjacent.bottom.isVisited()\n                ? neighbours.push(adjacent.bottom)\n                : null;\n        }\n        if (adjacent.left) {\n            !(square.walls.left || adjacent.left.walls.right) &&\n                !adjacent.left.isVisited()\n                ? neighbours.push(adjacent.left)\n                : null;\n        }\n        return neighbours;\n    }\n    DFS(labyrinth) {\n        Logger.info(\"Solving labyrinth using DFS\", labyrinth);\n        const stack = [];\n        // Find entrance square\n        const entrance = labyrinth.squares.find((square) => square.entrance);\n        if (!entrance) {\n            throw new Error(\"No entrance found\");\n        }\n        stack.push(entrance);\n        // Call recursive\n        return this.DFS_rec(stack, labyrinth, 0);\n    }\n    DFS_rec(stack, labyrinth, count) {\n        var _a, _b;\n        const currentSquare = stack[stack.length - 1];\n        const squarehtml = document.getElementById(currentSquare.getId());\n        if (this.debug)\n            if (squarehtml)\n                squarehtml.innerHTML = count.toString();\n        count++; // Debug only\n        if (!currentSquare.isVisited()) {\n            currentSquare.visit();\n            // this.stepService.labyrinthSteps[labyrinth.id].push(new Step(currentSquare, StepAction.VISIT, count));\n        }\n        if (currentSquare.exit) {\n            return stack;\n        }\n        const possibleMoves = this.getAccessibleNeighbours(currentSquare, labyrinth.squares);\n        if (possibleMoves.length == 0) {\n            stack.pop();\n            return stack;\n        }\n        for (const move of possibleMoves) {\n            stack.push(move);\n            const newStack = this.DFS_rec(stack, labyrinth, count);\n            // Pruned path\n            if (newStack.length == 0) {\n                if (this.debug)\n                    (_a = document.getElementById(move.getId())) === null || _a === void 0 ? void 0 : _a.classList.add(\"purple\"); // Debug only\n                // this.stepService.labyrinthSteps[labyrinth.id].push(new Step(currentSquare, StepAction.BACKTRACK, count));\n                stack.pop();\n            }\n            // Found exit\n            else if (newStack[newStack.length - 1].exit) {\n                return newStack;\n            }\n            // Is a dead end\n            if (this.debug)\n                (_b = document.getElementById(move.getId())) === null || _b === void 0 ? void 0 : _b.classList.add(\"red\"); // Debug only\n        }\n        // Didn't find any path\n        return [];\n    }\n    BFS(labyrinth) {\n        Logger.info(\"Solving labyrinth using BFS\", labyrinth);\n        // Find entrance square\n        const entrance = labyrinth.squares.find((square) => square.entrance);\n        if (!entrance) {\n            throw new Error(\"No entrance found\");\n        }\n        // Call iterative function\n        return this.BFS_it(labyrinth, entrance);\n    }\n    BFS_it(labyrinth, entrance) {\n        const queue = [];\n        const path = [];\n        let neighbourhtml;\n        let count = 0;\n        entrance.visit();\n        queue.push(entrance);\n        if (this.debug)\n            document.getElementById(entrance.getId()).innerHTML = count.toString(); // Debug only\n        count++;\n        while (queue.length > 0) {\n            const current = queue.shift();\n            const neighbours = this.getAccessibleNeighbours(current, labyrinth.squares);\n            for (let neighbour of neighbours) {\n                if (this.debug) {\n                    neighbourhtml = document.getElementById(neighbour.getId());\n                    document.getElementById(neighbour.getId()).innerHTML = count.toString(); // Debug only\n                }\n                count++;\n                neighbour.setParent(current);\n                if (!neighbour.isVisited()) {\n                    neighbour.visit();\n                    if (neighbour.exit) {\n                        Logger.info(\"Found exit\", neighbour);\n                        while (neighbour.getParent()) {\n                            path.push(neighbour);\n                            neighbour = neighbour.getParent();\n                        }\n                        return path;\n                    }\n                    queue.push(neighbour);\n                    if (this.debug)\n                        neighbourhtml === null || neighbourhtml === void 0 ? void 0 : neighbourhtml.classList.add(\"purple\"); // Debug only\n                }\n            }\n        }\n    }\n}\n","import { NodeGraph } from '../model/NodeGraph';\nimport { Node } from '../model/Node';\nimport { Position } from \"../model/Position\";\nclass AdjacentSquares {\n}\nexport class GraphMapper {\n    /**\n     * Finds all the adjacent squares to the given square (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    getAllNeighbours(square, squaresList) {\n        const positions = {\n            top: new Position(square.posX - 1, square.posY),\n            bottom: new Position(square.posX + 1, square.posY),\n            right: new Position(square.posX, square.posY + 1),\n            left: new Position(square.posX, square.posY - 1),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    getAccessibleNeighbours(square, squaresList) {\n        const neighbours = [];\n        const adjacent = this.getAllNeighbours(square, squaresList);\n        if (adjacent.top) {\n            !(square.walls.top || adjacent.top.walls.bottom) &&\n                !adjacent.top.isVisited()\n                ? neighbours.push(adjacent.top)\n                : null;\n        }\n        if (adjacent.right) {\n            !(square.walls.right || adjacent.right.walls.left) &&\n                !adjacent.right.isVisited()\n                ? neighbours.push(adjacent.right)\n                : null;\n        }\n        if (adjacent.bottom) {\n            !(square.walls.bottom || adjacent.bottom.walls.top) &&\n                !adjacent.bottom.isVisited()\n                ? neighbours.push(adjacent.bottom)\n                : null;\n        }\n        if (adjacent.left) {\n            !(square.walls.left || adjacent.left.walls.right) &&\n                !adjacent.left.isVisited()\n                ? neighbours.push(adjacent.left)\n                : null;\n        }\n        return neighbours;\n    }\n    /**\n     * Maps a labyrinth to a graph\n     * @param labyrinth\n     * @returns\n     */\n    mapLabyrinthToGraph(labyrinth) {\n        const nodeGraph = new NodeGraph(labyrinth.id);\n        // Convert labyrinth squares a list of nodes\n        for (const square of labyrinth.squares) {\n            let node = nodeGraph.getNode(square.getId());\n            if (!node) {\n                node = new Node(square.getId());\n                nodeGraph.addNode(node);\n            }\n            const neighbours = this.getAccessibleNeighbours(square, labyrinth.squares);\n            for (const neighbour of neighbours) {\n                let n_node = nodeGraph.getNode(neighbour.getId());\n                if (!n_node) {\n                    n_node = new Node(neighbour.getId());\n                    nodeGraph.addNode(n_node);\n                }\n                node.addAdjacentNode(n_node);\n            }\n        }\n        return nodeGraph;\n    }\n}\n","import { Square } from '../model/Square';\nimport { Labyrinth } from '../model/Labyrinth';\nexport class JsonMapper {\n    toLabyrinth(json, size, id) {\n        const _size = {\n            width: size,\n            height: size,\n        };\n        const squares = [];\n        const entrances = [];\n        const exits = [];\n        for (let i = 0; i < json.length; i++) {\n            const square = this.toSquare(json[i]);\n            if (square.entrance) {\n                entrances.push(square);\n            }\n            if (square.exit) {\n                exits.push(square);\n            }\n            squares.push(square);\n        }\n        return new Labyrinth(id, _size, squares, entrances, exits);\n    }\n    toSquare(json) {\n        const entrance = json.entrance ? true : false;\n        const exit = json.exit ? true : false;\n        const walls = {\n            top: json.walls[0],\n            right: json.walls[1],\n            bottom: json.walls[2],\n            left: json.walls[3],\n        };\n        return new Square(json.posX, json.posY, walls, exit, entrance);\n    }\n}\n","export class Labyrinth {\n    constructor(id, size, squares, entrances, exits) {\n        this.entrances = [];\n        this.exits = [];\n        this.id = id;\n        this.size = size;\n        this.squares = squares;\n        this.entrances = entrances;\n        this.exits = exits;\n    }\n    reset() {\n        this.squares.forEach(square => {\n            square.visited = false;\n        });\n    }\n}\n","export class Node {\n    constructor(id) {\n        this.id = id;\n        this.adjacentNodes = [];\n        this.visited = false;\n    }\n    getId() {\n        return this.id;\n    }\n    getAdjacentNodes() {\n        return this.adjacentNodes;\n    }\n    addAdjacentNode(node) {\n        this.adjacentNodes.push(node);\n        return this;\n    }\n    getVisited() {\n        return this.visited;\n    }\n    setVisited(visited) {\n        this.visited = visited;\n        return this;\n    }\n}\n","export class NodeGraph {\n    constructor(id) {\n        this.id = id;\n        this.nodes = {};\n    }\n    getNode(id) {\n        return this.nodes[id];\n    }\n    addNode(node) {\n        this.nodes[node.getId()] = node;\n        return this;\n    }\n}\n","export class Position {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals(position) {\n        return this.x == position.x && this.y == position.y;\n    }\n}\n","import { Position } from \"./Position\";\nexport class Square {\n    constructor(posX, posY, walls, exit, entrance) {\n        this.visited = false;\n        this.posX = posX;\n        this.posY = posY;\n        this.walls = walls;\n        this.exit = exit;\n        this.entrance = entrance;\n    }\n    getPosition() {\n        return new Position(this.posX, this.posY);\n    }\n    getId() {\n        return `${this.posX}-${this.posY}`;\n    }\n    isVisited() {\n        return this.visited;\n    }\n    visit() {\n        this.visited = true;\n    }\n    setParent(parent) {\n        this.parent = parent;\n        return this;\n    }\n    getParent() {\n        return this.parent;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { JsonMapper } from \"../mapping/JsonMapper\";\nexport class LabyrinthService {\n    constructor() {\n        this.jsonMapper = new JsonMapper();\n    }\n    getListOfLabyrinthsOfSizeFromAPI(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `http://localhost:3000/${size}`;\n            return fetch(url).then((response) => response.json());\n        });\n    }\n    getListOfLabyrinthsOfSizeFromFile(size) {\n        return require(`../../data/labyrinths.json`)[size.toString()];\n    }\n    getAllLabyrinthsOfSize(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const json = yield this.getListOfLabyrinthsOfSizeFromFile(size);\n            const labyrinthes = {};\n            for (const key in json) {\n                labyrinthes[key] = this.jsonMapper.toLabyrinth(json[key], size, key);\n            }\n            return labyrinthes;\n        });\n    }\n}\n","export class CssMapper {\n    constructor() {\n        this.themes = [\"base\", \"dark\"];\n        this.selectedTheme = \"base\";\n    }\n    getClassesFromSquare(square) {\n        const classes = [];\n        classes.push(square.walls.top ? \"wall-top\" : \"\");\n        classes.push(square.walls.right ? \"wall-right\" : \"\");\n        classes.push(square.walls.bottom ? \"wall-down\" : \"\");\n        classes.push(square.walls.left ? \"wall-left\" : \"\");\n        classes.push(square.exit ? \"exit\" : \"\");\n        classes.push(square.entrance ? \"entrance\" : \"\");\n        return classes;\n    }\n    getNextTheme() {\n        const index = this.themes.indexOf(this.selectedTheme);\n        this.selectedTheme = this.themes[(index + 1) % this.themes.length];\n        return this.selectedTheme;\n    }\n}\n","export class Logger {\n    static log(...message) {\n        console.log(this.logPrefix, ...message);\n    }\n    static info(...message) {\n        console.info(this.infoPrefix, ...message);\n    }\n    static warn(...message) {\n        console.warn(this.warnPrefix, ...message);\n    }\n    static error(...message) {\n        console.error(this.errorPrefix, ...message);\n    }\n}\nLogger.logPrefix = `[LOG-${new Date().toLocaleTimeString()}]`;\nLogger.infoPrefix = `[INFO-${new Date().toLocaleTimeString()}]`;\nLogger.warnPrefix = `[WARN-${new Date().toLocaleTimeString()}]`;\nLogger.errorPrefix = `[ERROR-${new Date().toLocaleTimeString()}]`;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Projet de parcours de labyrinthes\n */\nimport { LabyrinthService } from \"./service/LabyrinthService\";\nimport { CssMapper } from \"./service/StyleService\";\nimport { LabyrinthSolver } from \"./algorithm/LabyrinthSolver\";\nimport { GraphMapper } from \"./mapping/GraphMapper\";\n// Services\nconst labyrinthService = new LabyrinthService();\nconst styleService = new CssMapper();\nconst labyrinthSolver = new LabyrinthSolver();\n// Variables\nlet labyrinths;\nlet selectedLabyrinth;\n// Constants\nconst htmlElements = {\n    table: document.getElementById(\"labyrinthTable\"),\n    selectSize: document.getElementById(\"sizeSelect\"),\n    choixLabyrinthe: document.getElementById(\"labyrinthSelect\"),\n    runBFSButton: document.getElementById(\"runBFS\"),\n    runDFSButton: document.getElementById(\"runDFS\"),\n    debugCheckbox: document.getElementById(\"debugCheckbox\"),\n    resetButton: document.getElementById(\"resetButton\"),\n    toggleThemeButton: document.getElementById(\"toggleThemeButton\"),\n};\nconst squaresHTMLMap = {};\n// Dom manipulation functions\nfunction displayLabyrinth(labyrinth) {\n    const size = labyrinth.size;\n    const squares = labyrinth.squares;\n    // Empty the table\n    htmlElements.table.innerHTML = \"\";\n    for (let i = 0; i < size.height; i++) {\n        const row = document.createElement(\"tr\");\n        for (let j = 0; j < size.width; j++) {\n            const index = i * size.width + j;\n            const square = squares[index];\n            row.appendChild(squaresHTMLMap[square.getId()]);\n        }\n        htmlElements.table.appendChild(row);\n    }\n}\nfunction fillSelectLabyrinth() {\n    htmlElements.choixLabyrinthe.innerHTML = \"\";\n    const keys = Object.keys(labyrinths);\n    keys.forEach((key) => {\n        const option = document.createElement(\"option\");\n        option.value = key;\n        option.innerText = key;\n        htmlElements.choixLabyrinthe.appendChild(option);\n    });\n}\nfunction onClickResetButton() {\n    selectedLabyrinth === null || selectedLabyrinth === void 0 ? void 0 : selectedLabyrinth.reset();\n    const keys = Object.keys(squaresHTMLMap);\n    keys.forEach((key) => {\n        squaresHTMLMap[key].classList.remove(\"solution\");\n        squaresHTMLMap[key].classList.remove(\"purple\");\n        squaresHTMLMap[key].classList.remove(\"red\");\n        squaresHTMLMap[key].innerHTML = \"\";\n    });\n}\nfunction populateSquaresHTMLMap(squares) {\n    squares.forEach((square) => {\n        const squareElement = document.createElement(\"td\");\n        squareElement.id = square.getId();\n        squareElement.classList.add(\"square\");\n        squareElement.classList.add(\"box\");\n        squareElement.addEventListener(\"click\", onSquareClick);\n        styleService.getClassesFromSquare(square).forEach((cssClass) => {\n            cssClass != \"\" ? squareElement.classList.add(cssClass) : null;\n        });\n        squaresHTMLMap[square.getId()] = squareElement;\n    });\n}\n// Event handlers\nfunction onSelectSizeChange($event) {\n    const target = $event.target;\n    const size = parseInt(target.value);\n    labyrinthService.getAllLabyrinthsOfSize(size).then((labs) => {\n        labyrinths = labs;\n        fillSelectLabyrinth();\n        htmlElements.choixLabyrinthe.dispatchEvent(new Event(\"change\"));\n    });\n}\nfunction onSelectLabyrinthChange($event) {\n    const target = $event.target;\n    const labyrinthe = labyrinths[target.value];\n    onClickResetButton();\n    selectedLabyrinth = labyrinthe;\n    populateSquaresHTMLMap(labyrinthe.squares);\n    displayLabyrinth(labyrinthe);\n    const graphMapper = new GraphMapper();\n    graphMapper.mapLabyrinthToGraph(selectedLabyrinth);\n}\nfunction onClickBFS($event) {\n    var _a;\n    if (selectedLabyrinth) {\n        onClickResetButton();\n        (_a = labyrinthSolver.BFS(selectedLabyrinth)) === null || _a === void 0 ? void 0 : _a.forEach((square) => {\n            const squareElement = squaresHTMLMap[square.getId()];\n            if (!squareElement.classList.contains(\"exit\") &&\n                !squareElement.classList.contains(\"entrance\")) {\n                squareElement.classList.add(\"solution\");\n            }\n        });\n    }\n}\nfunction onClickDFS($event) {\n    var _a;\n    if (selectedLabyrinth) {\n        onClickResetButton();\n        (_a = labyrinthSolver.DFS(selectedLabyrinth)) === null || _a === void 0 ? void 0 : _a.forEach((square) => {\n            const squareElement = squaresHTMLMap[square.getId()];\n            if (!squareElement.classList.contains(\"exit\") &&\n                !squareElement.classList.contains(\"entrance\")) {\n                squareElement.classList.add(\"solution\");\n            }\n        });\n    }\n}\nfunction onCheckboxChange($event) {\n    labyrinthSolver.debug = $event.target.checked;\n}\nfunction onToggleThemeButton($event) {\n    const theme = styleService.getNextTheme();\n    document.body.classList.value = theme;\n}\n// Change background color of the clicked case\nfunction onSquareClick($event) {\n    const target = $event.target;\n    target.classList.toggle(\"red\");\n}\nfunction init() {\n    const sizes = 25;\n    // Init dom elements\n    htmlElements.selectSize.addEventListener(\"change\", onSelectSizeChange);\n    htmlElements.choixLabyrinthe.addEventListener(\"change\", onSelectLabyrinthChange);\n    htmlElements.runBFSButton.addEventListener(\"click\", onClickBFS);\n    htmlElements.runDFSButton.addEventListener(\"click\", onClickDFS);\n    htmlElements.debugCheckbox.addEventListener(\"change\", onCheckboxChange);\n    htmlElements.resetButton.addEventListener(\"click\", onClickResetButton);\n    htmlElements.toggleThemeButton.addEventListener(\"click\", onToggleThemeButton);\n    for (let i = 2; i < sizes; i++) {\n        const option = document.createElement(\"option\");\n        option.value = (i + 1).toString();\n        option.innerText = (i + 1).toString();\n        htmlElements.selectSize.appendChild(option);\n    }\n    htmlElements.selectSize.dispatchEvent(new Event(\"change\"));\n    labyrinthSolver.debug = htmlElements.debugCheckbox.checked;\n}\ninit();\n"],"names":[],"sourceRoot":""}