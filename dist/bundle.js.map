{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXyC;AACM;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,mBAAmB,uDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;;;;;;;;;;;;;;;;ACzB6C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;AC1BO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRsC;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B;AACA;AACA,kBAAkB,UAAU,GAAG,UAAU;AACzC;AACA;;;;;;;;;;;;;;;;ACfA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmD;AAC5C;AACP;AACA,8BAA8B,2DAAU;AACxC;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACpCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D,6BAA6B,gCAAgC;AAC7D,6BAA6B,gCAAgC;AAC7D,+BAA+B,gCAAgC;;;;;;;UCjB/D;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8D;AACd;AACY;AACpB;AACxC;AACA,6BAA6B,uEAAgB;AAC7C,sBAAsB,yDAAS;AAC/B,6BAA6B,qEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,iDAAM;AACd;AACA,KAAK;AACL,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA","sources":["webpack://algo-labyrinte/./src/mapping/CssMapper.ts","webpack://algo-labyrinte/./src/mapping/JsonMapper.ts","webpack://algo-labyrinte/./src/mapping/NodeCaseMapper.ts","webpack://algo-labyrinte/./src/model/Labyrinth.ts","webpack://algo-labyrinte/./src/model/Position.ts","webpack://algo-labyrinte/./src/model/Square.ts","webpack://algo-labyrinte/./src/service/LabyrinthService.ts","webpack://algo-labyrinte/./src/utils/Logger.ts","webpack://algo-labyrinte/webpack/bootstrap","webpack://algo-labyrinte/webpack/runtime/define property getters","webpack://algo-labyrinte/webpack/runtime/hasOwnProperty shorthand","webpack://algo-labyrinte/webpack/runtime/make namespace object","webpack://algo-labyrinte/./src/main.ts"],"sourcesContent":["export class CssMapper {\n    getClassesFromSquare(square) {\n        const classes = [];\n        classes.push(square.walls.top ? \"wall-top\" : \"\");\n        classes.push(square.walls.right ? \"wall-right\" : \"\");\n        classes.push(square.walls.bottom ? \"wall-down\" : \"\");\n        classes.push(square.walls.left ? \"wall-left\" : \"\");\n        classes.push(square.exit ? \"exit\" : \"\");\n        classes.push(square.entrance ? \"entrance\" : \"\");\n        return classes;\n    }\n}\n","import { Square } from '../model/Square';\nimport { Labyrinth } from '../model/Labyrinth';\nexport class JsonMapper {\n    toLabyrinth(json, size) {\n        const _size = {\n            width: size,\n            height: size,\n        };\n        const cases = [];\n        for (let i = 0; i < json.length; i++) {\n            cases.push(this.toSquare(json[i]));\n        }\n        return new Labyrinth(_size, cases);\n    }\n    toSquare(json) {\n        const entrance = json.entrance ? true : false;\n        const exit = json.exit ? true : false;\n        const walls = {\n            top: json.walls[0],\n            right: json.walls[1],\n            bottom: json.walls[2],\n            left: json.walls[3],\n        };\n        return new Square(json.posX, json.posY, walls, exit, entrance);\n    }\n}\n","import { Position } from '../model/Position';\nexport class NodeSquareMapper {\n    constructor() { }\n    findAdjacentCasesTo(square, squaresList) {\n        const labXLength = squaresList.map((c) => c.posX).reduce((a, b) => Math.max(a, b)) + 1;\n        const labYLength = squaresList.map((c) => c.posY).reduce((a, b) => Math.max(a, b)) + 1;\n        const offsets = {\n            top: (((square.posY + 1) % labYLength) + labYLength) % labYLength,\n            right: (((square.posX + 1) % labXLength) + labXLength) % labXLength,\n            bottom: (((square.posY - 1) % labYLength) + labYLength) % labYLength,\n            left: (((square.posX - 1) % labXLength) + labXLength) % labXLength\n        };\n        const positions = {\n            top: new Position(square.posX, offsets.top),\n            bottom: new Position(square.posX, offsets.bottom),\n            right: new Position(offsets.right, square.posY),\n            left: new Position(offsets.left, square.posY),\n        };\n        const adjacentSquares = squaresList.filter((square_) => {\n            return (square_.getPosition().equals(positions.top) ||\n                square_.getPosition().equals(positions.right) ||\n                square_.getPosition().equals(positions.bottom) ||\n                square_.getPosition().equals(positions.left));\n        });\n        return adjacentSquares;\n    }\n}\n","export class Labyrinth {\n    constructor(size, squares) {\n        this.size = size;\n        this.squares = squares;\n    }\n}\n","export class Position {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals(position) {\n        return this.x == position.x && this.y == position.y;\n    }\n}\n","import { Position } from \"./Position\";\nexport class Square {\n    constructor(posX, posY, walls, exit, entrance) {\n        this.posX = posX;\n        this.posY = posY;\n        this.walls = walls;\n        this.exit = exit;\n        this.entrance = entrance;\n    }\n    getPosition() {\n        return new Position(this.posX, this.posY);\n    }\n    getId() {\n        return `${this.posX}-${this.posY}`;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { JsonMapper } from \"../mapping/JsonMapper\";\nexport class LabyrinthService {\n    constructor() {\n        this.jsonMapper = new JsonMapper();\n    }\n    getListOfLabyrinthsOfSizeFromAPI(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `http://localhost:3000/${size}`;\n            return fetch(url).then((response) => response.json());\n        });\n    }\n    getLabyrinthOfSize(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const json = yield this.getListOfLabyrinthsOfSizeFromAPI(size);\n            return this.jsonMapper.toLabyrinth(json[\"ex-0\"], size);\n        });\n    }\n    getAllLabyrinthsOfSize(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const json = yield this.getListOfLabyrinthsOfSizeFromAPI(size);\n            const labyrinthes = {};\n            for (const key in json) {\n                labyrinthes[key] = this.jsonMapper.toLabyrinth(json[key], size);\n            }\n            return labyrinthes;\n        });\n    }\n}\n","export class Logger {\n    static log(...message) {\n        console.log(this.logPrefix, ...message);\n    }\n    static info(...message) {\n        console.info(this.infoPrefix, ...message);\n    }\n    static warn(...message) {\n        console.warn(this.warnPrefix, ...message);\n    }\n    static error(...message) {\n        console.error(this.errorPrefix, ...message);\n    }\n}\nLogger.logPrefix = `[LOG-${new Date().toLocaleTimeString()}]`;\nLogger.infoPrefix = `[INFO-${new Date().toLocaleTimeString()}]`;\nLogger.warnPrefix = `[WARN-${new Date().toLocaleTimeString()}]`;\nLogger.errorPrefix = `[ERROR-${new Date().toLocaleTimeString()}]`;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Projet de parcours de labyrinthes\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LabyrinthService } from \"./service/LabyrinthService\";\nimport { CssMapper } from \"./mapping/CssMapper\";\nimport { NodeSquareMapper } from './mapping/NodeCaseMapper';\nimport { Logger } from \"./utils/Logger\";\n// Services\nconst labyrinthService = new LabyrinthService();\nconst cssMapper = new CssMapper();\nconst nodeSquareMapper = new NodeSquareMapper();\n// Variables\nlet labyrinths;\n// Constants\nconst htmlElements = {\n    table: document.getElementById(\"labyrinthTable\"),\n    selectSize: document.getElementById(\"sizeSelect\"),\n    choixLabyrinthe: document.getElementById(\"labyrinthSelect\"),\n};\nconst squaresHTMLMap = {};\n// Dom manipulation functions\nfunction displayLabyrinth(labyrinth) {\n    const size = labyrinth.size;\n    const squares = labyrinth.squares;\n    // Empty the table\n    htmlElements.table.innerHTML = \"\";\n    for (let i = 0; i < size.height; i++) {\n        const row = document.createElement(\"tr\");\n        for (let j = 0; j < size.width; j++) {\n            const index = i * size.width + j;\n            const square = squares[index];\n            row.appendChild(squaresHTMLMap[square.getId()]);\n        }\n        htmlElements.table.appendChild(row);\n    }\n}\nfunction fillSelectLabyrinth() {\n    htmlElements.choixLabyrinthe.innerHTML = \"\";\n    const keys = Object.keys(labyrinths);\n    keys.forEach((key) => {\n        const option = document.createElement(\"option\");\n        option.value = key;\n        option.innerText = key;\n        htmlElements.choixLabyrinthe.appendChild(option);\n    });\n}\nfunction populateSquaresHTMLMap(squares) {\n    Logger.log(\"Populating casesHTMLMap ...\");\n    squares.forEach((square) => {\n        const squareElement = document.createElement(\"td\");\n        squareElement.id = square.getId();\n        squareElement.classList.add(\"square\");\n        squareElement.classList.add(\"box\");\n        squareElement.addEventListener(\"click\", onCaseClick);\n        cssMapper.getClassesFromSquare(square).forEach((cssClass) => {\n            cssClass != \"\" ? squareElement.classList.add(cssClass) : null;\n        });\n        Logger.log(\"Adding caseElement\", squareElement, \"to squaresHTMLMap\");\n        squaresHTMLMap[square.getId()] = squareElement;\n    });\n    Logger.log(\"Finished populating caseHTMLMap : \", squaresHTMLMap);\n}\n// Event handlers\nfunction onSelectSizeChange($event) {\n    const target = $event.target;\n    const size = parseInt(target.value);\n    labyrinthService.getAllLabyrinthsOfSize(size).then((labs) => {\n        labyrinths = labs;\n        fillSelectLabyrinth();\n        htmlElements.choixLabyrinthe.dispatchEvent(new Event(\"change\"));\n    });\n}\nfunction onSelectLabyrinthChange($event) {\n    const target = $event.target;\n    const labyrinthe = labyrinths[target.value];\n    populateSquaresHTMLMap(labyrinthe.squares);\n    displayLabyrinth(labyrinthe);\n}\nfunction treeSolver() {\n    /**\n     * Convertir le labyrinth en graphe\n     * Partir de la première node\n     * Si la node est la sortie, finir et remonter nombre de pas\n     * Si la node a déjà été visitée, remonter 0\n     * Si la node est un cul de sac, remonter 0\n     * Passer à la node suivante\n     */\n}\nfunction treeSolverRecursive() {\n}\n// Change background color of the clicked case\nfunction onCaseClick($event) {\n    const target = $event.target;\n    target.classList.toggle(\"red\");\n}\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sizes = 25;\n        htmlElements.selectSize.addEventListener(\"change\", onSelectSizeChange);\n        // Trigger the event (select size 3 by default)\n        htmlElements.choixLabyrinthe.addEventListener(\"change\", onSelectLabyrinthChange);\n        for (let i = 2; i < sizes; i++) {\n            const option = document.createElement(\"option\");\n            option.value = (i + 1).toString();\n            option.innerText = (i + 1).toString();\n            htmlElements.selectSize.appendChild(option);\n        }\n        htmlElements.selectSize.dispatchEvent(new Event(\"change\"));\n    });\n}\nmain();\n"],"names":[],"sourceRoot":""}