{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;AAA6C;AACJ;AACoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3NuC;AACF;AACQ;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAQ;AAC7B,wBAAwB,qDAAQ;AAChC,uBAAuB,qDAAQ;AAC/B,sBAAsB,qDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAK;AACnC;AACA;AACA;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3FyC;AACM;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;;;;;;;;;;;;;;;ACxCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRsC;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B;AACA;AACA,kBAAkB,UAAU,GAAG,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BsD;AACR;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAY;AACxC,gCAAgC,+DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACxEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmD;AACV;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAU;AACpC;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,SAAS;AACT;AACA;AACA,eAAe,mBAAO,CAAC,0DAA4B;AACnD;AACA;AACA,mCAAmC,mBAAO,CAAC,0DAA4B;AACvE,QAAQ,iDAAM,2BAA2B,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC7CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1B6D;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAe;AAC3B;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D,6BAA6B,gCAAgC;AAC7D,6BAA6B,gCAAgC;AAC7D,+BAA+B,gCAAgC;;;;;;;;;;;;;;;;;UCxB/D;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAC8D;AACR;AACQ;AACV;AACM;AACE;AAC5D;AACA,yBAAyB,uEAAgB;AACzC,qBAAqB,+DAAY;AACjC,wBAAwB,uEAAe;AACvC,uBAAuB,mEAAc;AACrC,wBAAwB,qEAAe;AACvC,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://algo-labyrinte/./src/algorithm/LabyrinthSolver.ts","webpack://algo-labyrinte/./src/mapping/GraphMapper.ts","webpack://algo-labyrinte/./src/mapping/JsonMapper.ts","webpack://algo-labyrinte/./src/model/Graph.ts","webpack://algo-labyrinte/./src/model/Labyrinth.ts","webpack://algo-labyrinte/./src/model/Node.ts","webpack://algo-labyrinte/./src/model/Position.ts","webpack://algo-labyrinte/./src/model/Square.ts","webpack://algo-labyrinte/./src/service/DisplayService.ts","webpack://algo-labyrinte/./src/service/LabyrinthService.ts","webpack://algo-labyrinte/./src/service/SettingsService.ts","webpack://algo-labyrinte/./src/service/StyleService.ts","webpack://algo-labyrinte/./src/utils/Logger.ts","webpack://algo-labyrinte/webpack/bootstrap","webpack://algo-labyrinte/webpack/runtime/define property getters","webpack://algo-labyrinte/webpack/runtime/hasOwnProperty shorthand","webpack://algo-labyrinte/webpack/runtime/make namespace object","webpack://algo-labyrinte/./src/main.ts"],"sourcesContent":["import { Position } from \"../model/Position\";\nimport { Logger } from \"../utils/Logger\";\nimport { SettingsService } from '../service/SettingsService';\nclass AdjacentSquares {\n}\n/*\n    The solver needs to return a detailed stack of steps taken to solve the labyrinth\n    The Step class should contain the following information:\n    - The square where the step was taken\n    - What action was taken, visit or backtracking, or both\n\n    */\nexport class LabyrinthSolver {\n    static getInstance() {\n        if (!LabyrinthSolver.instance) {\n            LabyrinthSolver.instance = new LabyrinthSolver();\n        }\n        return LabyrinthSolver.instance;\n    }\n    constructor() {\n        this.settingsService = SettingsService.getInstance();\n    }\n    /**\n     * Finds the adjacent squares to the given square looping around the labyrinth (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    findAdjacentSquaresToLooparound(square, squaresList) {\n        const labXLength = squaresList.map((c) => c.posX).reduce((a, b) => Math.max(a, b)) + 1;\n        const labYLength = squaresList.map((c) => c.posY).reduce((a, b) => Math.max(a, b)) + 1;\n        const offsets = {\n            top: (((square.posY + 1) % labYLength) + labYLength) % labYLength,\n            right: (((square.posX + 1) % labXLength) + labXLength) % labXLength,\n            bottom: (((square.posY - 1) % labYLength) + labYLength) % labYLength,\n            left: (((square.posX - 1) % labXLength) + labXLength) % labXLength,\n        };\n        const positions = {\n            top: new Position(square.posX, offsets.top),\n            bottom: new Position(square.posX, offsets.bottom),\n            right: new Position(offsets.right, square.posY),\n            left: new Position(offsets.left, square.posY),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    /**\n     * Finds all the adjacent squares to the given square (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    getAllNeighbours(square, squaresList) {\n        const positions = {\n            top: new Position(square.posX - 1, square.posY),\n            bottom: new Position(square.posX + 1, square.posY),\n            right: new Position(square.posX, square.posY + 1),\n            left: new Position(square.posX, square.posY - 1),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    getAccessibleNeighbours(square, squaresList) {\n        const neighbours = [];\n        const adjacent = this.getAllNeighbours(square, squaresList);\n        if (adjacent.top) {\n            !(square.walls.top || adjacent.top.walls.bottom) &&\n                !adjacent.top.isVisited()\n                ? neighbours.push(adjacent.top)\n                : null;\n        }\n        if (adjacent.right) {\n            !(square.walls.right || adjacent.right.walls.left) &&\n                !adjacent.right.isVisited()\n                ? neighbours.push(adjacent.right)\n                : null;\n        }\n        if (adjacent.bottom) {\n            !(square.walls.bottom || adjacent.bottom.walls.top) &&\n                !adjacent.bottom.isVisited()\n                ? neighbours.push(adjacent.bottom)\n                : null;\n        }\n        if (adjacent.left) {\n            !(square.walls.left || adjacent.left.walls.right) &&\n                !adjacent.left.isVisited()\n                ? neighbours.push(adjacent.left)\n                : null;\n        }\n        return neighbours;\n    }\n    DFS(labyrinth) {\n        Logger.debug(\"Solving labyrinth using DFS\", labyrinth);\n        const stack = [];\n        // Find entrance square\n        const entrance = labyrinth.squares.find((square) => square.entrance);\n        if (!entrance) {\n            throw new Error(\"No entrance found\");\n        }\n        stack.push(entrance);\n        // Call recursive\n        return this.DFS_rec(stack, labyrinth, 0);\n    }\n    DFS_rec(stack, labyrinth, count) {\n        var _a, _b;\n        const currentSquare = stack[stack.length - 1];\n        const squarehtml = document.getElementById(currentSquare.getId());\n        if (this.settingsService.settings.debug)\n            if (squarehtml)\n                squarehtml.innerHTML = count.toString();\n        count++; // Debug only\n        if (!currentSquare.isVisited()) {\n            currentSquare.visit();\n            // this.stepService.labyrinthSteps[labyrinth.id].push(new Step(currentSquare, StepAction.VISIT, count));\n        }\n        if (currentSquare.exit) {\n            return stack;\n        }\n        const possibleMoves = this.getAccessibleNeighbours(currentSquare, labyrinth.squares);\n        if (possibleMoves.length == 0) {\n            stack.pop();\n            return stack;\n        }\n        for (const move of possibleMoves) {\n            stack.push(move);\n            const newStack = this.DFS_rec(stack, labyrinth, count);\n            // Pruned path\n            if (newStack.length == 0) {\n                if (this.settingsService.settings.debug)\n                    (_a = document.getElementById(move.getId())) === null || _a === void 0 ? void 0 : _a.classList.add(\"purple\"); // Debug only\n                // this.stepService.labyrinthSteps[labyrinth.id].push(new Step(currentSquare, StepAction.BACKTRACK, count));\n                stack.pop();\n            }\n            // Found exit\n            else if (newStack[newStack.length - 1].exit) {\n                return newStack;\n            }\n            // Is a dead end\n            if (this.settingsService.settings.debug)\n                (_b = document.getElementById(move.getId())) === null || _b === void 0 ? void 0 : _b.classList.add(\"red\"); // Debug only\n        }\n        // Didn't find any path\n        return [];\n    }\n    BFS(labyrinth) {\n        Logger.debug(\"Solving labyrinth using BFS\", labyrinth);\n        // Find entrance square\n        const entrance = labyrinth.squares.find((square) => square.entrance);\n        if (!entrance) {\n            throw new Error(\"No entrance found\");\n        }\n        // Call iterative function\n        return this.BFS_it(labyrinth, entrance);\n    }\n    BFS_it(labyrinth, entrance) {\n        const queue = [];\n        const path = [];\n        let neighbourhtml;\n        let count = 0;\n        entrance.visit();\n        queue.push(entrance);\n        if (this.settingsService.settings.debug)\n            document.getElementById(entrance.getId()).innerHTML = count.toString(); // Debug only\n        count++;\n        while (queue.length > 0) {\n            const current = queue.shift();\n            const neighbours = this.getAccessibleNeighbours(current, labyrinth.squares);\n            for (let neighbour of neighbours) {\n                if (this.settingsService.settings.debug) {\n                    neighbourhtml = document.getElementById(neighbour.getId());\n                    document.getElementById(neighbour.getId()).innerHTML = count.toString(); // Debug only\n                }\n                count++;\n                neighbour.setParent(current);\n                if (!neighbour.isVisited()) {\n                    neighbour.visit();\n                    if (neighbour.exit) {\n                        Logger.debug(\"Found exit\", neighbour);\n                        while (neighbour.getParent()) {\n                            path.push(neighbour);\n                            neighbour = neighbour.getParent();\n                        }\n                        return path;\n                    }\n                    queue.push(neighbour);\n                    if (this.settingsService.settings.debug)\n                        neighbourhtml === null || neighbourhtml === void 0 ? void 0 : neighbourhtml.classList.add(\"purple\"); // Debug only\n                }\n            }\n        }\n    }\n}\n","import { Graph } from '../model/Graph';\nimport { Node } from '../model/Node';\nimport { Position } from \"../model/Position\";\nclass AdjacentSquares {\n}\nexport class GraphMapper {\n    /**\n     * Finds all the adjacent squares to the given square (top, right, bottom, left)\n     * @param square\n     * @param squaresList\n     * @returns\n     */\n    getAllNeighbours(square, squaresList) {\n        const positions = {\n            top: new Position(square.posX - 1, square.posY),\n            bottom: new Position(square.posX + 1, square.posY),\n            right: new Position(square.posX, square.posY + 1),\n            left: new Position(square.posX, square.posY - 1),\n        };\n        const adjacentSquares = new AdjacentSquares();\n        squaresList.map((square_) => {\n            square_.getPosition().equals(positions.top)\n                ? (adjacentSquares.top = square_)\n                : undefined;\n            square_.getPosition().equals(positions.right)\n                ? (adjacentSquares.right = square_)\n                : undefined;\n            square_.getPosition().equals(positions.bottom)\n                ? (adjacentSquares.bottom = square_)\n                : undefined;\n            square_.getPosition().equals(positions.left)\n                ? (adjacentSquares.left = square_)\n                : undefined;\n        });\n        return adjacentSquares;\n    }\n    getAccessibleNeighbours(square, squaresList) {\n        const neighbours = [];\n        const adjacent = this.getAllNeighbours(square, squaresList);\n        if (adjacent.top) {\n            !(square.walls.top || adjacent.top.walls.bottom) &&\n                !adjacent.top.isVisited()\n                ? neighbours.push(adjacent.top)\n                : null;\n        }\n        if (adjacent.right) {\n            !(square.walls.right || adjacent.right.walls.left) &&\n                !adjacent.right.isVisited()\n                ? neighbours.push(adjacent.right)\n                : null;\n        }\n        if (adjacent.bottom) {\n            !(square.walls.bottom || adjacent.bottom.walls.top) &&\n                !adjacent.bottom.isVisited()\n                ? neighbours.push(adjacent.bottom)\n                : null;\n        }\n        if (adjacent.left) {\n            !(square.walls.left || adjacent.left.walls.right) &&\n                !adjacent.left.isVisited()\n                ? neighbours.push(adjacent.left)\n                : null;\n        }\n        return neighbours;\n    }\n    /**\n     * Maps a labyrinth to a graph\n     * @param labyrinth\n     * @returns\n     */\n    mapLabyrinthToGraph(labyrinth) {\n        const nodeGraph = new Graph(labyrinth.id);\n        // Convert labyrinth squares a list of nodes\n        for (const square of labyrinth.squares) {\n            let node = nodeGraph.getNode(square.getId());\n            if (!node) {\n                node = new Node(square.getId());\n                nodeGraph.addNode(node);\n            }\n            const neighbours = this.getAccessibleNeighbours(square, labyrinth.squares);\n            for (const neighbour of neighbours) {\n                let n_node = nodeGraph.getNode(neighbour.getId());\n                if (!n_node) {\n                    n_node = new Node(neighbour.getId());\n                    nodeGraph.addNode(n_node);\n                }\n                node.addAdjacentNode(n_node);\n            }\n        }\n        return nodeGraph;\n    }\n}\n","import { Square } from '../model/Square';\nimport { Labyrinth } from '../model/Labyrinth';\nexport class JsonMapper {\n    static getInstance() {\n        if (!JsonMapper.instance) {\n            JsonMapper.instance = new JsonMapper();\n        }\n        return JsonMapper.instance;\n    }\n    toLabyrinth(json, size, id) {\n        const _size = {\n            width: size,\n            height: size,\n        };\n        const squares = [];\n        const entrances = [];\n        const exits = [];\n        for (let i = 0; i < json.length; i++) {\n            const square = this.toSquare(json[i]);\n            if (square.entrance) {\n                entrances.push(square);\n            }\n            if (square.exit) {\n                exits.push(square);\n            }\n            squares.push(square);\n        }\n        return new Labyrinth(id, _size, squares, entrances, exits);\n    }\n    toSquare(json) {\n        const entrance = json.entrance ? true : false;\n        const exit = json.exit ? true : false;\n        const walls = {\n            top: json.walls[0],\n            right: json.walls[1],\n            bottom: json.walls[2],\n            left: json.walls[3],\n        };\n        return new Square(json.posX, json.posY, walls, exit, entrance);\n    }\n}\n","export class Graph {\n    constructor(id) {\n        this.id = id;\n        this.nodes = {};\n    }\n    getNode(id) {\n        return this.nodes[id];\n    }\n    addNode(node) {\n        this.nodes[node.getId()] = node;\n        return this;\n    }\n}\n","export class Labyrinth {\n    constructor(id, size, squares, entrances, exits) {\n        this.entrances = [];\n        this.exits = [];\n        this.id = id;\n        this.size = size;\n        this.squares = squares;\n        this.entrances = entrances;\n        this.exits = exits;\n    }\n    reset() {\n        this.squares.forEach(square => {\n            square.visited = false;\n        });\n    }\n}\n","export class Node {\n    constructor(id) {\n        this.id = id;\n        this.adjacentNodes = [];\n        this.visited = false;\n    }\n    getId() {\n        return this.id;\n    }\n    getAdjacentNodes() {\n        return this.adjacentNodes;\n    }\n    addAdjacentNode(node) {\n        this.adjacentNodes.push(node);\n        return this;\n    }\n    getVisited() {\n        return this.visited;\n    }\n    setVisited(visited) {\n        this.visited = visited;\n        return this;\n    }\n}\n","export class Position {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals(position) {\n        return this.x == position.x && this.y == position.y;\n    }\n}\n","import { Position } from \"./Position\";\nexport class Square {\n    constructor(posX, posY, walls, exit, entrance) {\n        this.visited = false;\n        this.posX = posX;\n        this.posY = posY;\n        this.walls = walls;\n        this.exit = exit;\n        this.entrance = entrance;\n    }\n    getPosition() {\n        return new Position(this.posX, this.posY);\n    }\n    getId() {\n        return `${this.posX}-${this.posY}`;\n    }\n    isVisited() {\n        return this.visited;\n    }\n    visit() {\n        this.visited = true;\n    }\n    setParent(parent) {\n        this.parent = parent;\n        return this;\n    }\n    getParent() {\n        return this.parent;\n    }\n}\n","import { LabyrinthService } from \"./LabyrinthService\";\nimport { StyleService } from \"./StyleService\";\n/**\n * Handles the display of the labyrinth to the browser\n */\nexport class DisplayService {\n    constructor() {\n        this.htmlElements = {\n            table: document.getElementById(\"labyrinthTable\"),\n            selectSize: document.getElementById(\"sizeSelect\"),\n            choixLabyrinthe: document.getElementById(\"labyrinthSelect\"),\n            runBFSButton: document.getElementById(\"runBFS\"),\n            runDFSButton: document.getElementById(\"runDFS\"),\n            debugCheckbox: document.getElementById(\"debugCheckbox\"),\n            resetButton: document.getElementById(\"resetButton\"),\n            toggleThemeButton: document.getElementById(\"toggleThemeButton\"),\n        };\n        this.squaresHTMLMap = {};\n        this.styleService = StyleService.getInstance();\n        this.labyrinthService = LabyrinthService.getInstance();\n    }\n    static getInstance() {\n        if (!DisplayService.instance) {\n            DisplayService.instance = new DisplayService();\n        }\n        return DisplayService.instance;\n    }\n    fillSelectSize(sizes) {\n        for (const size of sizes) {\n            const option = document.createElement(\"option\");\n            option.value = (size).toString();\n            option.innerText = (size).toString();\n            this.htmlElements.selectSize.appendChild(option);\n        }\n    }\n    fillSelectLabyrinth(choices) {\n        this.htmlElements.choixLabyrinthe.innerHTML = \"\";\n        choices.forEach((choice) => {\n            const option = document.createElement(\"option\");\n            option.value = choice;\n            option.innerText = choice;\n            this.htmlElements.choixLabyrinthe.appendChild(option);\n        });\n    }\n    displayLabyrinth(labyrinth) {\n        const size = labyrinth.size;\n        const squares = labyrinth.squares;\n        // Empty the table\n        this.htmlElements.table.innerHTML = \"\";\n        for (let i = 0; i < size.height; i++) {\n            const row = document.createElement(\"tr\");\n            for (let j = 0; j < size.width; j++) {\n                const index = i * size.width + j;\n                const square = squares[index];\n                row.appendChild(this.squaresHTMLMap[square.getId()]);\n            }\n            this.htmlElements.table.appendChild(row);\n        }\n    }\n    populateSquaresHTMLMap(squares) {\n        squares.forEach((square) => {\n            const squareElement = document.createElement(\"td\");\n            squareElement.id = square.getId();\n            squareElement.classList.add(\"square\");\n            squareElement.classList.add(\"box\");\n            // squareElement.addEventListener(\"click\", onSquareClick);\n            this.styleService.getClassesFromSquare(square).forEach((cssClass) => {\n                cssClass != \"\" ? squareElement.classList.add(cssClass) : null;\n            });\n            this.squaresHTMLMap[square.getId()] = squareElement;\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { JsonMapper } from \"../mapping/JsonMapper\";\nimport { Logger } from \"../utils/Logger\";\nexport class LabyrinthService {\n    static getInstance() {\n        if (!LabyrinthService.instance) {\n            LabyrinthService.instance = new LabyrinthService();\n        }\n        return LabyrinthService.instance;\n    }\n    constructor() {\n        this.jsonMapper = JsonMapper.getInstance();\n    }\n    getListOfLabyrinthsOfSizeFromAPI(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `http://localhost:3000/${size}`;\n            return fetch(url).then((response) => response.json());\n        });\n    }\n    getListOfLabyrinthsOfSizeFromFile(size) {\n        return require(`../../data/labyrinths.json`)[size.toString()];\n    }\n    getAvailableSizes() {\n        const number = Object.keys(require(`../../data/labyrinths.json`)).map((size) => parseInt(size));\n        Logger.debug(`Available sizes: ${number}`);\n        return number;\n    }\n    getAllLabyrinthsOfSize(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const json = yield this.getListOfLabyrinthsOfSizeFromFile(size);\n            const labyrinthes = {};\n            for (const key in json) {\n                labyrinthes[key] = this.jsonMapper.toLabyrinth(json[key], size, key);\n            }\n            return labyrinthes;\n        });\n    }\n}\n","export class SettingsService {\n    static getInstance() {\n        if (!SettingsService.instance) {\n            SettingsService.instance = new SettingsService();\n        }\n        return SettingsService.instance;\n    }\n    constructor() {\n        this.settings = {\n            \"debug\": false\n        };\n    }\n}\n","export class StyleService {\n    static getInstance() {\n        if (!StyleService.instance) {\n            StyleService.instance = new StyleService();\n        }\n        return StyleService.instance;\n    }\n    constructor() {\n        this.themes = [\"base\", \"dark\"];\n        this.selectedTheme = \"base\";\n    }\n    getClassesFromSquare(square) {\n        const classes = [];\n        classes.push(square.walls.top ? \"wall-top\" : \"\");\n        classes.push(square.walls.right ? \"wall-right\" : \"\");\n        classes.push(square.walls.bottom ? \"wall-down\" : \"\");\n        classes.push(square.walls.left ? \"wall-left\" : \"\");\n        classes.push(square.exit ? \"exit\" : \"\");\n        classes.push(square.entrance ? \"entrance\" : \"\");\n        return classes;\n    }\n    getNextTheme() {\n        const index = this.themes.indexOf(this.selectedTheme);\n        this.selectedTheme = this.themes[(index + 1) % this.themes.length];\n        return this.selectedTheme;\n    }\n}\n","import { SettingsService } from \"../service/SettingsService\";\nexport class Logger {\n    constructor() { }\n    static log(...message) {\n        console.log(this.logPrefix, ...message);\n    }\n    static info(...message) {\n        console.info(this.infoPrefix, ...message);\n    }\n    static warn(...message) {\n        console.warn(this.warnPrefix, ...message);\n    }\n    static error(...message) {\n        console.error(this.errorPrefix, ...message);\n    }\n    static debug(...message) {\n        if (SettingsService.getInstance().settings.debug) {\n            console.debug(this.logPrefix, ...message);\n        }\n    }\n}\nLogger.logPrefix = `[LOG-${new Date().toLocaleTimeString()}]`;\nLogger.infoPrefix = `[INFO-${new Date().toLocaleTimeString()}]`;\nLogger.warnPrefix = `[WARN-${new Date().toLocaleTimeString()}]`;\nLogger.errorPrefix = `[ERROR-${new Date().toLocaleTimeString()}]`;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Projet de parcours de labyrinthes\n */\nimport { LabyrinthService } from \"./service/LabyrinthService\";\nimport { StyleService } from \"./service/StyleService\";\nimport { LabyrinthSolver } from \"./algorithm/LabyrinthSolver\";\nimport { GraphMapper } from \"./mapping/GraphMapper\";\nimport { DisplayService } from \"./service/DisplayService\";\nimport { SettingsService } from \"./service/SettingsService\";\n// Services\nconst labyrinthService = LabyrinthService.getInstance();\nconst styleService = StyleService.getInstance();\nconst labyrinthSolver = LabyrinthSolver.getInstance();\nconst displayService = DisplayService.getInstance();\nconst settingsService = SettingsService.getInstance();\nsettingsService.settings.debug = displayService.htmlElements.debugCheckbox.checked; // Checkbox is saved on f5 refresh so we need to set it here to keep the value\n// Variables\nlet labyrinths;\nlet selectedLabyrinth;\n// Dom manipulation functions\nfunction onClickResetButton() {\n    selectedLabyrinth === null || selectedLabyrinth === void 0 ? void 0 : selectedLabyrinth.reset();\n    const keys = Object.keys(displayService.squaresHTMLMap);\n    keys.forEach((key) => {\n        displayService.squaresHTMLMap[key].classList.remove(\"solution\");\n        displayService.squaresHTMLMap[key].classList.remove(\"purple\");\n        displayService.squaresHTMLMap[key].classList.remove(\"red\");\n        displayService.squaresHTMLMap[key].innerHTML = \"\";\n    });\n}\n// Event handlers\nfunction onSelectSizeChange($event) {\n    const target = $event.target;\n    const size = parseInt(target.value);\n    labyrinthService.getAllLabyrinthsOfSize(size).then((labs) => {\n        labyrinths = labs;\n        displayService.fillSelectLabyrinth(Object.keys(labyrinths));\n        displayService.htmlElements.choixLabyrinthe.dispatchEvent(new Event(\"change\"));\n    });\n}\nfunction onSelectLabyrinthChange($event) {\n    const target = $event.target;\n    const labyrinthe = labyrinths[target.value];\n    onClickResetButton();\n    selectedLabyrinth = labyrinthe;\n    displayService.populateSquaresHTMLMap(labyrinthe.squares);\n    displayService.displayLabyrinth(labyrinthe);\n    const graphMapper = new GraphMapper();\n    graphMapper.mapLabyrinthToGraph(selectedLabyrinth);\n}\nfunction onClickBFS($event) {\n    var _a;\n    if (selectedLabyrinth) {\n        onClickResetButton();\n        (_a = labyrinthSolver.BFS(selectedLabyrinth)) === null || _a === void 0 ? void 0 : _a.forEach((square) => {\n            const squareElement = displayService.squaresHTMLMap[square.getId()];\n            if (!squareElement.classList.contains(\"exit\") &&\n                !squareElement.classList.contains(\"entrance\")) {\n                squareElement.classList.add(\"solution\");\n            }\n        });\n    }\n}\nfunction onClickDFS($event) {\n    var _a;\n    if (selectedLabyrinth) {\n        onClickResetButton();\n        (_a = labyrinthSolver.DFS(selectedLabyrinth)) === null || _a === void 0 ? void 0 : _a.forEach((square) => {\n            const squareElement = displayService.squaresHTMLMap[square.getId()];\n            if (!squareElement.classList.contains(\"exit\") &&\n                !squareElement.classList.contains(\"entrance\")) {\n                squareElement.classList.add(\"solution\");\n            }\n        });\n    }\n}\nfunction onCheckboxChange($event) {\n    settingsService.settings.debug = $event.target.checked;\n}\nfunction onToggleThemeButton($event) {\n    const theme = styleService.getNextTheme();\n    document.body.classList.value = theme;\n}\n// Change background color of the clicked case\nfunction onSquareClick($event) {\n    const target = $event.target;\n    target.classList.toggle(\"red\");\n}\nfunction init() {\n    // Init dom elements\n    displayService.htmlElements.selectSize.addEventListener(\"change\", onSelectSizeChange);\n    displayService.htmlElements.choixLabyrinthe.addEventListener(\"change\", onSelectLabyrinthChange);\n    displayService.htmlElements.runBFSButton.addEventListener(\"click\", onClickBFS);\n    displayService.htmlElements.runDFSButton.addEventListener(\"click\", onClickDFS);\n    displayService.htmlElements.debugCheckbox.addEventListener(\"change\", onCheckboxChange);\n    displayService.htmlElements.resetButton.addEventListener(\"click\", onClickResetButton);\n    displayService.htmlElements.toggleThemeButton.addEventListener(\"click\", onToggleThemeButton);\n    displayService.fillSelectSize(labyrinthService.getAvailableSizes());\n    displayService.htmlElements.selectSize.dispatchEvent(new Event(\"change\"));\n}\ninit();\n"],"names":[],"sourceRoot":""}